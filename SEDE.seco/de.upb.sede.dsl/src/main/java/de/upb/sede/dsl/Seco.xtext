grammar de.upb.sede.dsl.Seco with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate seco "http://www.upb.de/sede/dsl/Seco"


Entries:
    (
    	elements+=Assignment |
    	elements+=EntityDefinition |
    	elements+=Yield
    )*;
  
    
/*
 * E.g.:
 *  a = fruits.Apple::__construct({i1=0,i2=0,i3=10,i4=10})
 */
 

Operation:
	(=> contextField = Field | entityName = EntityName) ("::")
		 method=MethodName "(" "{"? 
				(
					(args+=Argument)		// First argument
					(',' args+=Argument)*  // Additional Arguments
				)? "}" ? ")" 
;
								


Argument:
	(((indexed ?= "i" index = INT)| parameterName = ID) '=')? value = FieldValue
;


Assignment:
	(=> assignedFields += Field (multiAssignment ?= ',' assignedFields+= Field)* "=")? value = FieldValue ";"
;


/*
 * E.g.:
 * define a.b.C wraps d.e.F extends g.H, i.J {
 * 		method: static Construct (Number, String, some.Entity) -> (Bool, some.other.Entity) {
 * 			"runtime-data" = {
 * 				"some_data_java_needs" = 10
 * 			}
 * 		};
 * }
 */
EntityDefinition:
	(def ?= "define" | refine ?= "refine") qualifiedName = EntityName 
	(
		(wrapper ?= "wraps" 
			wrappedEntity = EntityName
		)? &
		(extension ?= "extends" 
			baseEntities += EntityName 
			(',' baseEntities += EntityName)*
		)?
	)
	"{"
		(
			methods += EntityMethod |
			marshals += EntityMarshal |
			casts += EntityCast
		)* 
	"}"
;


EntityMethod:
	(property = EntityMethodProp)? "method:" methodName = MethodName
	 paramSignature = EntityMethodParamSignature 
	 (realization ?= 'realized' 'by' 
	 	methodRealization = MethodName
	 	// realizationArguments EntityMethodParamSignature // TODO parameter redirects
	 )?
	 (additionalData = Json)? ';'
;

enum EntityMethodProp:
	STATIC = 'static' | PURE = 'pure'
;


EntityMethodParamSignature:
	{EntityMethodParamSignature} "(" 
	 	(parameters += EntityMethodParam ("," parameters += EntityMethodParam)*)?
	 ")" 
	 ('->' '(' 
	 	(outputs += EntityMethodParam ("," outputs += EntityMethodParam)*)? 
	 ')')?
;


EntityMethodParam:
	(
		(final ?= "final")? &
		(yielded ?= "yield")?
	)  
	parameterType = EntityName
	  (
	  	parameterName = ID
	  )?
	  (
	  	valueFixed ?= "=" fixedValue =FieldValue
	  )?
;


EntityMarshal:
	"marshal:" direction = TransformDirection resultingSemantics = ID? (additionalData = Json)? ';'
;

EntityCast:
	"cast:" direction = TransformDirection resultingEntity = EntityName (additionalData = Json)? ';' 
;

enum TransformDirection:
	BI = '<->' | BI = 'to and from' | 
	TO = '->' | TO = 'to' |
	FROM = '<-' | FROM = 'from'
;

Yield:
	=> "yield" yields += FieldValue (multiYield ?= ',' yields += FieldValue)* ';'?
;



QualifiedName  returns ecore::EString:
	ID ('.' ID)*
;
	
EntityName:
     name = QualifiedName '$'?;
     
MethodName:
	name = ID '!'?;
    
StringConst returns ecore::EString:
	 STRING;
	
BoolConst returns ecore::EString:
	 "True" | "true" | "False" | "false" | "TRUE" | "FALSE";
	
NullConst returns ecore::EString:
	 "Null" | "null" | "NULL" | "NuLL";
	
NumberConst returns ecore::EString:
	 ("-" | "+")? INT ("." INT)? (("e"|"E") ("-" | "+") INT)?;
	 
	 
Field:
	name = ID (-> dereference ?= '->' memeber = __TerminalField)?;
	
__TerminalField returns FieldValue:
	FieldValue
;
	
FieldValue:
	( -> cast ?='(' castTarget = EntityName ')'  castValue = __TerminalField) |
	number = NumberConst |
	string = StringConst | 
	bool = BoolConst | 
	null ?= NullConst | 
//	(entityReference ?= "ref"  entity = EntityName ('::' method=MethodName)?) | // TODO: do we need entity references?
	(=> operation = Operation) | 
	(field = Field)
;


Json returns ecore::EString:
	'{' 
		((JsonObjectMemeber)
		(',' JsonObjectMemeber)*)? 
	'}';

JsonObjectMemeber returns ecore::EString:
	STRING ':' JsonObjectValue;
	
	
JsonObjectValue returns ecore::EString:
	Json | StringConst | JsonArray |  'true' | 'false' | 'null' | NumberConst;

JsonArray returns ecore::EString:
	'[' ((JsonObjectValue) (',' JsonObjectValue)*)? ']';

